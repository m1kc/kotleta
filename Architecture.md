# Архитектура, блеать!

Гениальность задумок >>9000 и держим планку. Инфа 100%.

## Приложение

### Почему оно запустилось?

* Просто так.
* Приложение могло быть вызвано другим приложением. Следовательно, нужны аргументы командной строки.
* Приложение могло быть вызвано автоматически. Нам нужен запуск приложения по времени, при загрузке системы и по событиям (приход SMS, пропал интернет, etc). Пользователь в любой момент может посмотреть запланированные автозапуски и отключить их. События:
 * Звонок
 * SMS
 * Интернет (появился/пропал)
 * GRPS/WiFi (включили/отключили)
* Приложение могло быть вызвано в качестве заставки, обоев или клавиатуры.

### Как оно запустилось?

Единый classpath для всех приложений:

* Классы J2ME
* bootstrap
* Механизм передачи сообщений
* TCUILite

_При этом Main класс берётся из архива Toolkit. Сделано это для того, чтобы сразу после запуска приложение установило соединение xBUS, а в дальнейшем таким образом в корневой класс MIDlet или Kotlet можно передавать события вроде powerOff, powerOn, onMinimize, destroyApp и прочие._

### Чего оно делает после запуска?

Итак, мы таки запустились. Вызвался `main()`. Дальше по логике вещей должен создаться Displayable. Но не всегда. Стоит оставить приложению возможность работать как демон.

## Межпроцессное взаимодействие

Если приложение готово принимать сообщения - типа, `Exchange.registerListener(object)`. Адресом служит пакет приложения (`com.pupkin.makaronina`). Сообщение - суть сериализованный объект любого типа либо просто строка (`handleObject()`, `handleString()`).